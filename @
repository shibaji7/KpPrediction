##
#
##

import os
import pandas as pd
import datetime as dt
import multiprocessing
from multiprocessing import Pool
import threading

import util
import database as db

global lock
lock = multiprocessing.Lock()


class DeterministicModelPerDataPoint(threading.Thread):
    def __init__(self, y, reg, clf, dn, data, trw, m):
        threading.Thread.__init__(self)
        self.y = y
        self.reg = reg
        self.clf = clf
        self.dn = dn
        self.data = data
        self.trw = trw
        self.mI = 1
        self.model = m
        self.fname = "out/det.%s.pred.csv"%m
        return

    def data_windowing(self, trw=None):
        _o = self.data[0]
        _xparams = self.data[1]
        _yparam = self.data[2]
        if trw is None: trw = self.trw
        _tstart = self.dn - dt.timedelta(days=trw) # training window start inclusive
        _tend = self.dn - dt.timedelta(hours=3) # training window end inclusive
        self._o_train = _o[(_o["Date_WS"] >= _tstart) & (_o["Date_WS"] <= _tend)]
        self._o_test = _o[(_o["Date_WS"] == _pred_point_time)]
        if trw is not None:
            self._o_train = self._o_train[self._o_train[_yparam] >= 5.5]
            pass
        return

    def run(self):
        prt = 0.7
        print("-->Process for date:%s"%self.dn)
        _xparams = self.data[1]
        _yparam = self.data[2]
        mI = self.mI
        reg = self.reg
        clf = self.clf
        _forecast_time = self.dn + dt.timedelta(hours = (mI*3))
        _pred_point_time = self.dn # Time at which forecast is taking place
        self.data_windowing()
        _o_train = self._o_train
        _o_test = self._o_test
        if len(_o_test) == 1:
            X_train = _o_train.as_matrix(_xparams)
            y_train = np.array(_o_train[_yparam]).reshape(len(_o_train),1)
            X_test = _o_test.as_matrix(_xparams)
            y_test = np.array(_o_test[_yparam]).reshape(len(_o_test),1)
            pr = clf.predict_proba(X_test)[0,0]
            if pr > prt:
                self.data_windowing(self.trw*10)
                _o_train = self._o_train
                X_train = _o_train.as_matrix(_xparams)
                y_train = np.array(_o_train[_yparam]).reshape(len(_o_train),1)
                pass
            reg.fit(X_train, y_train)
            if len(reg.predict(X_test).shape) == 2: self.y_pred = reg.predict(X_test)[0,0]
            else: self.y_pred = reg.predict(X_test)[0]
            self.y_obs = y_test[0,0]
            pass
        else: pass
        #store_prediction_to_file("")
        return


def run_detrmnstic_model_per_year(details):
    y = details[0]
    reg = details[1]
    clf = details[2]
    data = details[3]
    trw = details[4]
    m = details[5]
    _dates = [dt.datetime(y,6,1) + dt.timedelta(hours=i*3) for i in range(8*30)]
    print("-->Process for year:%d"%y)
    for dn in _dates: 
        th = DeterministicModelPerDataPoint(y,reg,clf,dn,data,trw,m)
        th.start()
        pass
    return

def run_model_based_on_deterministic_algoritms(model, trw=27):
    print("--> Loading data...")
    _o, _xparams, _yparam = db.load_data_for_deterministic_reg()
    f_clf = "out/rf.pkl"
    clf = util.get_best_determinsistic_classifier(f_clf)
    reg = util.get_regressor(model, trw)
    Y = 1995
    years = range(Y,Y+1)
    regs = [reg] * len(years)
    clfs = [clf] * len(years)
    Trw = [trw] * len(years)
    models = [model] * len(years)
    data_array = [(_o, _xparams, _yparam)] * len(years)
    _a = []
    for x,y,z,k,t,m in zip(years, regs, clfs, data_array, Trw, models): _a.append((x,y,z,k,t,m))
    year_pool = Pool(10)
    year_pool.map(run_detrmnstic_model_per_year, _a)
    return
